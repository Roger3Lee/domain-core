---

description: 
globs: **/*.sql
alwaysApply: false

---

# SQL开发指南

本文档提供了SQL开发的全面指南，涵盖从命名约定和表设计到查询优化、安全性和测试等各个方面，旨在促进数据库管理和应用程序开发的最佳实践。

## 实施这些原则

这些指南建立在以下核心原则之上：

- 原则1：清晰性和可维护性：确保SQL代码和数据库结构易于理解、修改和维护。
- 原则2：性能和可扩展性：设计数据库和查询以获得最佳性能，并能够处理不断增长的数据和用户负载。
- 原则3：数据完整性和安全性：保护数据的准确性、一致性，并防止未经授权的访问或丢失。
- 原则4：一致性：在数据库模式和SQL代码中应用统一标准。

## 目录

- 规则1：命名约定
- 规则2：表设计
- 规则3：查询编写
- 规则4：索引策略
- 规则5：安全指南
- 规则6：性能优化技巧
- 规则7：事务指南
- 规则8：迁移最佳实践
- 规则9：代码示例
- 规则10：测试指南
- 规则11：监控实践

## 规则1：命名约定

标题：数据库对象的一致命名
描述：为数据库对象（如表、列、外键、视图、触发器、索引和约束）定义标准命名约定，以确保数据库模式的清晰性和一致性。

**好的示例：**

**通用规则：**

- 对所有数据库对象使用snake_case
- 表名使用复数形式（例如：`users`、`orders`）
- 列名使用单数形式（例如：`user_id`、`order_date`）
- 外键应以引用表名为前缀（例如：`user_id`）
- 存储过程使用动词_名词格式（例如：`get_user`、`update_order`）

**前缀：**

- 视图：`v_`
- 触发器：`trg_`
- 索引：`idx_`
- 约束：
  - 主键：`pk_`
  - 外键：`fk_`
  - 唯一约束：`uq_`
  - 检查约束：`ck_`

## 规则2：表设计

标题：数据库表设计的最佳实践
描述：概述表设计的最佳实践，包括主键、适当的数据类型、规范化（至少达到3NF）、包含时间戳列（`created_at`、`updated_at`）、使用外键约束维护引用完整性、考虑软删除（`deleted_at`），以及对频繁查询的列进行战略性索引。

**好的示例：**

**最佳实践：**

- 始终包含主键。
- 为列使用适当的数据类型。
- 规范化至少到3NF，除非有充分理由不这样做。
- 包含`created_at`和`updated_at`时间戳列。
- 使用外键约束维护引用完整性。
- 考虑使用`deleted_at`时间戳进行软删除。
- 为频繁查询的列添加适当的索引。

**常用列：**

- `id: BIGINT AUTO_INCREMENT PRIMARY KEY`
- `created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP`
- `updated_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP`
- `deleted_at: TIMESTAMP NULL`

## 规则3：查询编写

标题：编写有效和可读SQL查询的指南
描述：提供SQL查询格式化以提高可读性和优化性能的指南。包括关于`SELECT`语句的建议、使用`EXISTS`与`IN`的比较、适当的索引、尽可能避免相关子查询、使用`EXPLAIN`分析查询性能、考虑查询执行计划，以及使用批处理操作进行批量数据修改。

**好的示例：**

**格式化：**

- 对SQL关键字使用大写（例如：`SELECT`、`FROM`、`WHERE`）。
- 每行放置一个子句以提高可读性。
- 缩进子查询和公用表表达式（CTE）。
- 在`SELECT`语句中垂直对齐列列表。
- 使用有意义且简洁的表别名。

**性能：**

- 避免`SELECT *`；仅指定需要的列。
- 在子查询中使用`EXISTS`而不是`IN`以获得更好的性能，特别是在大数据集上。
- 确保`WHERE`子句、`JOIN`条件和`ORDER BY`子句中使用的列有适当的索引。
- 当可以使用等效连接或非相关子查询时，避免使用相关子查询。
- 使用`EXPLAIN`（或您的RDBMS的类似命令）来分析查询性能并理解执行计划。
- 考虑查询执行计划以识别瓶颈。
- 对批量更新或插入使用批处理操作以减少开销。

**示例查询：**

```sql
SELECT
    u.id,
    u.first_name,
    u.last_name,
    o.order_date
FROM
    users u
LEFT JOIN
    orders o ON u.id = o.user_id
WHERE
    u.deleted_at IS NULL
    AND o.status = 'COMPLETED'
ORDER BY
    o.order_date DESC;
```

## 规则4：索引策略

标题：有效数据库索引的原则
描述：涵盖创建和管理数据库索引的原则。包括对外键列建立索引、对`WHERE`子句或`JOIN`条件中频繁使用的列建立索引、考虑为多列查询建立复合索引，以及避免过度索引，这可能会负面影响写入性能。还提到监控索引使用情况和删除未使用的索引。

**好的示例：**

**原则：**

- 为外键列建立索引。
- 为频繁查询的列建立索引（出现在`WHERE`、`JOIN`、`ORDER BY`、`GROUP BY`子句中的列）。
- 为过滤或排序多个列的查询考虑复合索引。复合索引中列的顺序很重要。
- 避免过度索引，因为每个索引都消耗存储空间并为写入操作（插入、更新、删除）增加开销。
- 监控索引使用情况以识别未充分利用或未使用的索引。
- 删除未使用的索引以回收空间并减少维护开销。

**类型（常见示例）：**

- B树（大多数关系数据库的默认类型，适用于范围查询和等值查询）
- 哈希（适用于精确等值检查，不适用于范围查询）
- 全文（用于搜索列中的文本内容）
- 空间（用于索引地理数据）

## 规则5：安全指南

标题：数据库安全最佳实践
描述：突出数据库的基本安全措施，包括使用预处理语句或参数化查询以防止SQL注入、实施适当的访问控制机制（授予最小权限）、对敏感数据进行静态和传输加密、审计对敏感数据的访问、进行定期安全审查、建立健全的备份和恢复策略，以及使用适当的用户权限。

**好的示例：**

- 使用预处理语句（或参数化查询）防止SQL注入漏洞。
- 实施适当的访问控制：仅授予用户和应用程序执行其任务所需的权限（最小权限原则）。
- 加密敏感数据：保护静态数据（例如：使用TDE或列级加密）和传输中的数据（例如：使用SSL/TLS）。
- 审计敏感数据访问：记录并监控对关键数据的访问以检测和调查可疑活动。
- 进行定期安全审查和漏洞评估。
- 实施全面的备份和恢复策略。
- 为不同的应用程序角色或服务使用适当且不同的用户权限。

## 规则6：性能优化技巧

标题：优化数据库性能的技巧
描述：提供优化数据库性能的技巧集合。包括为列选择适当的数据类型以节省空间并提高比较速度、规范化数据库设计以减少冗余、战略性建立索引、编写优化查询、使用连接池高效管理数据库连接、在适当的地方实施缓存机制、执行定期数据库维护（如`VACUUM`、`ANALYZE`或索引重建），以及持续监控查询性能。

**好的示例：**

- 使用适当的数据类型：选择能可靠存储所需数据的最小数据类型。
- 规范化数据库设计：减少数据冗余并提高数据完整性，这也有利于性能。
- 战略性建立索引：为搜索条件和连接中使用的列创建索引，但避免过度索引。
- 优化查询：重写低效查询，避免`SELECT *`，使用`EXPLAIN`分析执行计划。
- 使用连接池：减少为每个请求建立数据库连接的开销。
- 在适当的地方实施缓存：缓存频繁访问的相对静态数据以减少数据库负载。
- 执行定期维护：像`VACUUM`（在PostgreSQL中）、`ANALYZE`或重建索引等任务可以提高性能。
- 监控查询性能：识别并解决慢查询或资源密集型查询。

## 规则7：事务指南

标题：管理数据库事务的指南
描述：提供有效管理数据库事务的指南。关键建议包括保持事务尽可能短以最小化锁定和资源争用、使用适当的隔离级别以平衡一致性和并发性需求、优雅地处理潜在的死锁、在事务内实施健全的错误处理，以及考虑对更复杂的事务逻辑使用保存点。

**好的示例：**

- 保持事务尽可能短：长时间运行的事务会长时间持有锁，影响并发性。
- 使用适当的隔离级别：了解权衡（例如：`READ COMMITTED`、`REPEATABLE READ`、`SERIALIZABLE`）并选择满足应用程序一致性要求而不过度损害性能的级别。
- 适当处理死锁：实施机制以检测死锁并在出现死锁时重试事务。
- 实施适当的错误处理：确保在出现错误时回滚事务以维护数据一致性。
- 对于可能需要部分回滚的复杂事务，考虑使用保存点。

## 规则8：迁移最佳实践

标题：数据库模式迁移的最佳实践
描述：概述管理数据库模式更改和数据迁移的最佳实践。包括对所有数据库更改进行版本控制、使用专用迁移工具（如Flyway或Liquibase）、设计可逆的迁移（只要可能）、在应用到生产环境之前在非生产环境中彻底测试迁移、包含回滚脚本或程序，以及清楚地记录任何破坏性更改。

**好的示例：**

- 对所有数据库更改进行版本控制：将模式定义和迁移脚本存储在版本控制系统中（例如：Git）。
- 使用迁移工具（例如：Flyway、Liquibase）：这些工具帮助系统地管理、跟踪和应用数据库更改。
- 尽可能使迁移可逆：设计更改以便在必要时可以撤销。
- 在尽可能接近生产环境的非生产环境中彻底测试迁移。
- 为迁移包含回滚脚本或程序。
- 记录破坏性更改并与相关团队沟通。

## 规则9：代码示例

标题：说明性SQL代码示例
描述：提供实用的SQL代码示例，包括表创建和存储过程定义，以演示各种指南的应用，如命名约定、数据类型选择和索引。

**好的示例：**

**表创建：**

```sql
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT,
    email VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    status ENUM('ACTIVE', 'INACTIVE', 'SUSPENDED') DEFAULT 'ACTIVE',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    PRIMARY KEY (pk_users_id), -- pk_前缀示例
    UNIQUE INDEX uq_users_email (email), -- 唯一索引的uq_前缀示例
    INDEX idx_users_status (status) -- 一般索引的idx_前缀示例
);
```

*注意：`pk_users_id`演示了主键前缀。`AUTO_INCREMENT`语法可能因RDBMS而异（例如：`SERIAL`或`IDENTITY`）。枚举用法也有所不同。*

**存储过程：**

```sql
-- DELIMITER和存储过程创建的语法可能因RDBMS而异。
-- 这是一个类似MySQL的示例。
DELIMITER //
CREATE PROCEDURE get_active_users(IN status_param VARCHAR(20))
BEGIN
    SELECT
        id,
        email,
        first_name,
        last_name
    FROM
        users
    WHERE
        status = status_param
        AND deleted_at IS NULL;
END //
DELIMITER ;
```

## 规则10：测试指南

标题：数据库测试指南
描述：涵盖全面测试数据库组件和交互的指南。包括使用代表性数据量测试以发现性能问题、在测试数据中包含边缘情况和边界条件、在各种负载条件下测试性能、验证数据完整性约束（如主键、外键、唯一约束、检查约束）、测试存储过程和函数的正确性、验证迁移脚本（包括升级和回滚）以及测试回滚程序。

**好的示例：**

- 使用代表性数据量进行测试：小的测试数据集可能不会暴露在大量数据下出现的性能问题。
- 在测试数据中包含边缘情况和边界条件。
- 在负载下测试性能以模拟真实世界的使用模式。
- 验证数据完整性约束：尝试插入/更新违反约束的数据以确保约束得到执行。
- 测试存储过程、函数和触发器的正确行为和逻辑。
- 验证迁移脚本：测试迁移的应用和（如果适用）它们的回滚。
- 测试回滚程序以确保在部署失败的情况下它们按预期工作。

## 规则11：监控实践

标题：数据库监控实践
描述：详细说明监控数据库健康和性能的基本实践。包括监控整体查询性能、跟踪可能指示瓶颈的慢查询、监控磁盘使用情况以防止存储问题、跟踪连接池使用情况以确保其大小适当、监控缓存命中率以评估缓存效果、为关键问题设置警报（例如：高错误率、磁盘空间不足、长时间运行的查询），以及进行定期性能审查。

**好的示例：**

- 监控查询性能：使用数据库特定工具或APM解决方案跟踪查询的执行时间和资源消耗。
- 跟踪慢查询：识别和分析超过性能阈值的查询。
- 监控磁盘使用情况：关注存储容量和I/O性能。
- 跟踪连接池使用情况：确保连接池没有耗尽并正在高效地管理连接。
- 监控缓存命中率：针对数据库缓存或与数据库交互的应用程序级缓存。
- 为关键问题设置警报（例如：磁盘空间不足、高CPU使用率、长时间运行的事务、复制延迟）。
- 进行定期性能审查以主动识别和解决潜在问题。
