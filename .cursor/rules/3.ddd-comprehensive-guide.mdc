# 综合DDD开发规范指南

本指南整合了项目DDD（领域驱动设计）开发的核心规范，涵盖了从领域模型定义到具体编码实现的关键方面。

---

## 1. 领域模型结构与XML配置 (`domain-model-structure.mdc`)

- 项目采用DDD分层架构：business/core(领域模型和服务接口)、business/application(应用服务)、present/api(API定义)、present/server(REST控制器)
- 领域模型XML配置文件位于1-domain目录下，定义聚合根和关联实体结构，不允许修改
- 自动生成的领域模型类(*Domain.java)和服务接口(*Service.java)位于business/core层，不允许修改
- `<domain>`节点定义聚合根实体，包含folder、name、description、main-table属性
- `<related>`节点定义关联实体，包含table、many、fk、redundancy属性
- `<ref>`节点定义引用关系，包含name、table、many、fk、redundancy属性
- 外键关系格式为"主表字段:关联表字段"，支持一对一和一对多关系
- 冗余关系通过redundancy属性定义，用于数据同步
- 中间表也需要定义相应的`<related>`节点，支持复杂的多对多关系
- 引用关系支持嵌套，可以在关联实体上定义进一步的引用

### 示例: domain-regulars.xml
```xml
<domains>
    <!-- 定义"常客管理"聚合根 -->
    <domain folder="regulars" name="notarial_regulars" description="常客管理" main-table="notarial_regulars">
        
        <!-- 关联"人员"表，一对多关系 -->
        <related table="notarial_regulars_person" many="true" fk="id:regulars_id">
            <!-- 在"人员"实体上定义到"文件"和"文档"的引用 -->
            <ref name="document" table="notarial_regulars_document" many="true" fk="id:ref_id"/>
            <ref name="file" table="notarial_regulars_file" many="true" fk="id:ref_id"/>
        </related>
        
        <!-- 关联"文档"表，一对多关系 -->
        <related table="notarial_regulars_document" many="true" fk="id:regulars_id"/>
        
        <!-- 关联"文件"表，一对多关系 -->
        <related table="notarial_regulars_file" many="true" fk="id:regulars_id"/>
    </domain>
</domains>
```

---

## 2. 领域服务核心方法 (`domain-service-methods.mdc`)

- 使用`Domain.load(id, service)`静态方法通过主键加载聚合根实体
- 使用`Domain.loadByKey(key, keyLambda, service)`通过业务键加载实体
- 使用`domain.loadRelated(relatedClass)`加载指定类型的所有关联实体
- 使用`domain.loadRelated(relatedClass, Consumer<LambdaQuery<T>>)`使用Consumer配置查询条件加载关联实体
- 使用`domain.loadRelated(relatedClass, lambdaQuery)`直接传入LambdaQuery加载关联实体
- 使用`service.find(request)`根据查询条件查找领域实体，会根据request中的LoadFlag加载关联数据
- 使用`service.find(domain, loadFlag)`根据领域对象和加载标志查找实体
- 使用`service.insert(domain)`插入新的领域实体，自动处理关联实体的外键设置
- 使用`service.update(newDomain, originalDomain, false)`进行标准更新，比较差异只更新变化的字段
- 使用`service.delete(id)`删除主实体，支持级联软删除
- 使用`service.deleteRelated(relatedClass, lambdaQuery)`删除符合条件的关联实体
- 使用`service.queryPage(relatedClass, pageDomain, lambdaQuery)`分页查询关联实体
- 使用`service.queryList(relatedClass, lambdaQuery)`列表查询关联实体，数据量大时慎用

### 示例: 加载实体
```java
// 1. 通过主键ID加载
NotarialRegularsDomain domain = NotarialRegularsDomain.load(1L, regularsService);

// 2. 通过业务键(如业务编号code)加载
NotarialRegularsDomain domainByKey = NotarialRegularsDomain.loadByKey(
          "REG001", NotarialRegularsDomain::getCode, regularsService);
```

### 示例: 加载关联实体（重构后的用法）
```java
// 1. 先加载主实体
NotarialRegularsDomain domain = NotarialRegularsDomain.load(1L, regularsService);

// 2. 加载所有关联的 "人员" 实体
domain.loadRelated(NotarialRegularsDomain.NotarialRegularsPersonDomain.class);

// 3. 使用Consumer配置查询条件加载关联实体
domain.loadRelated(NotarialRegularsDomain.NotarialRegularsPersonDomain.class, query -> {
    query.eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getStatus, "ACTIVE")
         .like(NotarialRegularsDomain.NotarialRegularsPersonDomain::getName, "张")
         .orderBy(NotarialRegularsDomain.NotarialRegularsPersonDomain::getCreateTime, Order.DESC);
});

// 4. 直接传入预构建的LambdaQuery
LambdaQuery<NotarialRegularsDomain.NotarialRegularsPersonDomain> query = 
    LambdaQuery.of(NotarialRegularsDomain.NotarialRegularsPersonDomain.class)
        .eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getType, "VIP")
        .orderBy(NotarialRegularsDomain.NotarialRegularsPersonDomain::getId, Order.ASC);
domain.loadRelated(NotarialRegularsDomain.NotarialRegularsPersonDomain.class, query);
```

### 2.3 支持的操作符（Op 枚举）
- `EQ` (=)、`NE` (<>)：等于/不等于
- `GT` (>)、`GE` (>=)、`LT` (<)、`LE` (<=)：大于/大于等于/小于/小于等于
- `LIKE`、`NOT_LIKE`：模糊匹配
- `LIKE_LEFT`、`LIKE_RIGHT`：左匹配/右匹配
- `IN`、`NOT_IN`：包含/不包含
- `ISNULL`、`NOTNULL`：为空/不为空

### 2.4 排序（Order 枚举）
- `ASC`：升序
- `DESC`：降序

---

## 3. 聚合根关联加载

### 3.1 BaseAggregateDomain 关联加载方法
```java
// 加载所有关联实体
public <T> void loadRelated(Class<T> tClass);

// 使用 Consumer 配置查询条件
public <T> void loadRelated(Class<T> tClass, Consumer<LambdaQuery<T>> consumer);

// 直接传入 LambdaQuery
public <T> void loadRelated(Class<T> tClass, LambdaQuery<T> query);
```

### 3.2 使用示例
```java
// 加载所有家庭成员
domain.loadRelated(FamilyDomain.FamilyMemberDomain.class);

// 加载特定条件的家庭成员
domain.loadRelated(FamilyDomain.FamilyMemberDomain.class, query -> {
    query.eq(FamilyDomain.FamilyMemberDomain::getStatus, "ACTIVE")
         .orderBy(FamilyDomain.FamilyMemberDomain::getCreateTime, Order.DESC);
});

// 使用预构建的查询
LambdaQuery<FamilyDomain.FamilyMemberDomain> query = LambdaQuery.of(FamilyDomain.FamilyMemberDomain.class)
    .like(FamilyDomain.FamilyMemberDomain::getName, "张");
domain.loadRelated(FamilyDomain.FamilyMemberDomain.class, query);
```

---

## 4. CRUD操作实践

- 新增操作：使用`Convert.INSTANCE.convert()`转换Request为Domain，调用`service.insert()`执行插入
- 查询详情：使用`Domain.load()`加载主实体，然后使用`loadRelated()`加载关联实体
- 更新操作：先查询原始Domain，转换Request为新Domain，设置LoadFlag，调用`service.update(newDomain, originalDomain)`
- 删除操作：使用`service.delete(id)`删除主实体，自动级联删除关联实体
- 关联实体新增：通过更新主实体方式添加关联实体，设置相应的LoadFlag
- 关联实体删除：使用`service.deleteRelated()`删除特定的关联实体
- 分页查询：使用`service.queryPage()`进行分页查询，构建LambdaQuery过滤条件
- 批量操作：合理使用批量查询和批量更新，避免循环调用数据库
- 嵌套加载：上一次`loadRelated()`的数据可作为下一次查询的条件，支持多层级关联
- 事务处理：复杂操作确保在同一事务中完成，使用`@Transactional`注解
- 错误处理：资源不存在时返回404，业务规则验证失败返回400

### 示例: 新增操作
```java
// 应用服务层方法
public Long addRegulars(NotarialRegularsAddRequest request) {
    // 1. 使用MapStruct将Request DTO转换为Domain对象
    NotarialRegularsDomain domain = Convert.INSTANCE.convert(request);
    // 2. 调用领域服务的insert方法，返回主键ID
    return regularsService.insert(domain);
}
```

### 示例: 查询操作 (查询详情)
```java
// 应用服务层方法
private NotarialRegularsDomain getRegularsDetail(Long regularsId) {
    // 1. 使用静态load方法加载主实体
    NotarialRegularsDomain domain = NotarialRegularsDomain.load(regularsId, regularsService);

    // 2. 使用实例方法loadRelated加载关联的文档和文件
    // 查询顶层文件(refId为空)
    domain.loadRelated(NotarialRegularsDomain.NotarialRegularsDocumentDomain.class, query -> {
        query.isNull(NotarialRegularsDomain.NotarialRegularsDocumentDomain::getRefId);
    });
    domain.loadRelated(NotarialRegularsDomain.NotarialRegularsFileDomain.class, query -> {
        query.isNull(NotarialRegularsDomain.NotarialRegularsFileDomain::getRefId);
    });

    return domain;
}
```

### 示例: 更新操作
```java
// 应用服务层方法
public Boolean editRegulars(NotarialRegularsEditRequest request) {
    // 1. 获取更新前的原始数据（包含关联实体）
    NotarialRegularsDomain originalDomain = getRegularsDetail(request.getId());

    // 2. 将包含更新数据的Request DTO转换为新的Domain对象
    NotarialRegularsDomain newDomain = Convert.INSTANCE.convertEdit(request);

    // 3. 设置LoadFlag，指定本次需要更新的关联实体范围
    newDomain.setLoadFlag(NotarialRegularsDomain.LoadFlag.builder()
            .loadNotarialRegularsDocument(true) // 更新文档
            .loadNotarialRegularsFile(true)     // 更新文件
            .build());

    // 4. 执行更新，false表示不重新从数据库加载数据，直接使用提供的originalDomain进行比较
    return regularsService.update(newDomain, originalDomain);
}
```

### 示例: 删除关联实体
```java
// 应用服务层方法
public Boolean delPerson(Long regularsId, Long personId) {
    // 1. 删除关联人本身
    regularsService.deleteRelated(NotarialRegularsDomain.NotarialRegularsPersonDomain.class,
        LambdaQuery.of(NotarialRegularsDomain.NotarialRegularsPersonDomain.class)
            .eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getRegularsId, regularsId)
            .eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getId, personId));

    // 2. 删除与该关联人相关的文档和文件
    regularsService.deleteRelated(NotarialRegularsDomain.NotarialRegularsDocumentDomain.class,
        LambdaQuery.of(NotarialRegularsDomain.NotarialRegularsDocumentDomain.class)
            .eq(NotarialRegularsDomain.NotarialRegularsDocumentDomain::getRegularsId, regularsId)
            .eq(NotarialRegularsDomain.NotarialRegularsDocumentDomain::getRefId, personId));

    return true;
}
```

---

## 5. `LoadFlag`数据加载策略 (`load-flag-usage.mdc`)

- 使用`LoadFlag.builder()`构建精确的数据加载策略，避免N+1查询问题
- 查询详情时使用`LoadFlag`加载所有相关的关联数据
- 更新操作时使用`LoadFlag`只加载需要更新的关联数据，其他关联数据保持不变
- `LoadFlag`既控制查询时需要加载哪些关联数据，也控制更新时需要更新哪些关联数据范围
- 在`domain.setLoadFlag()`中设置加载标志后，调用`service.find()`方法加载数据
- `LoadFlag`中每个关联实体都有对应的布尔属性，如`loadNotarialRegularsPerson(true)`
- 不设置`LoadFlag`或设置为`false`的关联实体不会被加载或更新
- 合理使用`LoadFlag`可以显著提升查询性能，减少不必要的数据库访问
- 在级联更新场景中，`LoadFlag`确保只更新指定的关联实体，避免误操作
- `LoadFlag`支持链式调用，可以一次性设置多个关联实体的加载标志

### 示例: 使用LoadFlag控制加载/更新范围
```java
// 使用场景：只加载/更新人员和文件信息，不加载/更新文档信息

// 1. 构建LoadFlag实例
NotarialRegularsDomain.LoadFlag loadFlag = LoadFlag.builder()
    .loadNotarialRegularsPerson(true)    // 加载/更新人员信息
    .loadNotarialRegularsDocument(false)  // 不加载/更新文档信息
    .loadNotarialRegularsFile(true)       // 加载/更新文件信息
    .build();

// 2. 将LoadFlag设置到Domain对象中
domain.setLoadFlag(loadFlag);

// 3. 在查询或更新时使用
// 查询时，只会加载Person和File两个关联表的数据
regularsService.find(domain, loadFlag);

// 更新时，只会处理Person和File两个关联表的变更
regularsService.update(newDomain, originalDomain);
```

---

## 6. `LambdaQuery`查询条件构建 (`lambda-query-usage.mdc`)

- 使用`LambdaQuery.of(Class<T>)`创建类型安全的查询对象
- 支持链式调用，直接使用`.eq()`, `.like()`, `.in()`等方法构建查询条件
- 支持多种操作符：`eq`(等于)、`like`(模糊匹配)、`in`(包含)、`isNull`(为空)、`gt`(大于)、`lt`(小于)
- 多个过滤条件默认是`AND`关系，可使用`.and()`和`.or()`组合复杂条件
- 支持`orderBy()`和`thenBy()`进行排序
- 动态查询条件根据参数是否为空决定是否添加到查询
- 支持AND/OR嵌套查询，用于复杂的业务场景
- 所有查询方法要求必须有过滤条件，不允许无条件查询

### 示例: 构建查询条件
```java
// 场景：分页查询常客的关联人员，并支持按姓名模糊查询
public PageResult<NotarialRegularsPersonResponse> pagePerson(Long regularsId, NotarialRegularsPersonPageRequest request) {
    
    // 1. 构建基础查询条件
    LambdaQuery<NotarialRegularsDomain.NotarialRegularsPersonDomain> query = 
        LambdaQuery.of(NotarialRegularsDomain.NotarialRegularsPersonDomain.class)
            .eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getRegularsId, regularsId);

    // 2. 动态添加模糊查询条件
    if (StringUtils.isNotEmpty(request.getNameHant())) {
        query.like(NotarialRegularsDomain.NotarialRegularsPersonDomain::getNameHant, request.getNameHant());
    }
    
    // 3. 添加排序
    query.orderBy(NotarialRegularsDomain.NotarialRegularsPersonDomain::getCreateTime, Order.DESC);
    
    // 4. 执行分页查询
    IPage<NotarialRegularsDomain.NotarialRegularsPersonDomain> page = regularsService.queryPage(
        NotarialRegularsDomain.NotarialRegularsPersonDomain.class,
        pageDomain,
        query
    );
    // ...
}
```

### 示例: 复杂查询条件（AND/OR组合）
```java
// 构建复杂查询：(status = 'ACTIVE' AND name like '张%') OR (type = 'VIP')
LambdaQuery<NotarialRegularsDomain.NotarialRegularsPersonDomain> query = 
    LambdaQuery.of(NotarialRegularsDomain.NotarialRegularsPersonDomain.class)
        .and(subQuery -> {
            subQuery.eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getStatus, "ACTIVE")
                   .likeRight(NotarialRegularsDomain.NotarialRegularsPersonDomain::getName, "张");
        })
        .or(subQuery -> {
            subQuery.eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getType, "VIP");
        });
```

---

## 7. `LambdaOrder`排序条件构建 (`lambda-order-usage.mdc`)

- 排序功能已集成到`LambdaQuery`中，使用`orderBy()`和`thenBy()`方法
- 使用Lambda表达式引用排序字段，如`query.orderBy(PersonDomain::getCreateTime, Order.DESC)`
- `Order`枚举支持`ASC`(升序)和`DESC`(降序)两种排序方式
- `Order.getOrder(orderBy)`方法可以从字符串转换为`Order`枚举
- 多字段排序使用`thenBy()`方法，按调用顺序应用排序规则
- 日期字段排序常用于按创建时间或修改时间排序
- 数字字段排序常用于按ID或优先级排序
- 字符串字段排序会按字典序进行，支持中文排序
- 排序字段建议添加数据库索引以提升查询性能

### 示例: 构建排序条件
```java
// 场景：分页查询，并支持动态排序
public PageResult<NotarialRegularsPersonResponse> pagePerson(NotarialRegularsPersonPageRequest request) {
    
    LambdaQuery<NotarialRegularsDomain.NotarialRegularsPersonDomain> query = 
        LambdaQuery.of(NotarialRegularsDomain.NotarialRegularsPersonDomain.class)
            .eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getRegularsId, request.getRegularsId());
    
    // 1. 根据前端传入的字段名和排序方向添加排序
    if (StringUtils.isNotEmpty(request.getOrderField())) {
        query.orderBy(request.getOrderField(), Order.getOrder(request.getOrderBy()));
    } else {
        // 2. 默认排序
        query.orderBy(NotarialRegularsDomain.NotarialRegularsPersonDomain::getCreateTime, Order.DESC);
    }

    // 3. 执行查询
    IPage<NotarialRegularsDomain.NotarialRegularsPersonDomain> page = regularsService.queryPage(
        NotarialRegularsDomain.NotarialRegularsPersonDomain.class,
        pageDomain,
        query
    );
    // ...
}

// 示例2: 多字段排序
LambdaQuery<NotarialRegularsDomain.NotarialRegularsPersonDomain> query = 
    LambdaQuery.of(NotarialRegularsDomain.NotarialRegularsPersonDomain.class)
        .eq(NotarialRegularsDomain.NotarialRegularsPersonDomain::getStatus, "ACTIVE")
        .orderBy(NotarialRegularsDomain.NotarialRegularsPersonDomain::getCreateTime, Order.DESC)
        .thenBy(NotarialRegularsDomain.NotarialRegularsPersonDomain::getId, Order.ASC);
```

---

如需详细示例、模板或接口说明，请参考 domain-core、domain-generator、domain-sample 目录下的最新代码与文档。
    LambdaOrder.build(NotarialRegularsDomain.NotarialRegularsPersonDomain::getCreateTime, Order.DESC);
```


