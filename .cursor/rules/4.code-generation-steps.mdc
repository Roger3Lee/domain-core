---
alwaysApply: true
---
- 步骤1：分析领域模型XML配置，读取domain-*.xml文件理解领域模型结构
- 步骤2：生成或更新DTO类，为每个实体包括中间表生成对应的DTO
- 步骤3：定义Request和Response对象，根据接口需求决定继承DTO还是创建独立类
- 步骤4：设计REST资源路径和标准CRUD端点，遵循RESTful API设计原则
- 步骤5：实现Controller层，使用@RestController和@RequestMapping注解
- 步骤6：实现应用服务层，创建ApplicationService和Converter
- 步骤7：使用领域服务进行数据操作，正确处理LoadFlag控制数据加载范围
- 步骤8：处理中间表的1:1引用，使用@Mapping注解映射合并的字段
- 步骤9：确保事务一致性，使用@Transactional确保数据一致性
- 步骤10：代码规范检查，验证CRUD操作完整性和业务逻辑正确性
- 步骤11：性能优化检查，避免N+1查询问题，合理使用LoadFlag
- 步骤12：异常处理，统一错误响应格式，合理的重试和降级策略

### 示例: 关键步骤的代码实现

#### 步骤 3 & 4: 定义Request和Controller端点
```java
// Request DTO
@Data
@EqualsAndHashCode(callSuper = true)
@ApiModel(value = "编辑常客请求")
public class NotarialRegularsEditRequest extends NotarialRegularsDTO {
    // 继承DTO所有字段
}

// Controller
@Api(tags = "常客管理")
@RestController
@RequestMapping("/api/v1/regulars")
public class RegularsController {
    @Autowired
    private RegularsApplicationService applicationService;

    @PutMapping("/{id}")
    @ApiOperation("编辑常客")
    public ApiResponse<Boolean> edit(@RequestBody @Valid NotarialRegularsEditRequest request) {
        return ApiResponse.success(applicationService.editRegulars(request));
    }
}
```

#### 步骤 6, 7 & 9: 实现应用服务
```java
@Service
public class RegularsApplicationService {
    @Autowired
    private NotarialRegularsService domainService;
    @Autowired
    private NotarialRegularsConverter converter;
    
    @Transactional // 步骤9: 确保事务一致性
    public Boolean editRegulars(NotarialRegularsEditRequest request) {
        // 步骤7: 使用领域服务进行数据操作
        NotarialRegularsDomain originalDomain = domainService.find(...); 
        NotarialRegularsDomain newDomain = converter.toDomain(request);
        
        // 步骤7: 正确处理LoadFlag
        newDomain.setLoadFlag(LoadFlag.builder()...build());
        
        return domainService.update(newDomain, originalDomain, false);
    }
}
```


