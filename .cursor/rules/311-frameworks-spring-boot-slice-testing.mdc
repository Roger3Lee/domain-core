---

description: 
globs: 
alwaysApply: false

---

# Spring Boot切片测试

Spring Boot切片测试允许您隔离地测试应用程序的特定层或"切片"，提供比完整集成测试更快、更专注的测试。这种方法有助于保持测试清晰度，减少测试执行时间，并提高可维护性。

## 实施这些原则

这些指南建立在以下核心原则之上：

- **层隔离**：独立测试每个应用程序层，而不加载整个Spring上下文
- **专注测试**：使用适当的切片注解仅加载特定功能所需的组件
- **模拟依赖**：模拟外部依赖和其他层，在切片级别实现真正的单元测试
- **快速执行**：最小化Spring上下文加载以实现快速测试反馈循环

## 目录

- 规则1：使用@WebMvcTest进行Web层测试
- 规则2：使用@JdbcTest进行Repository层测试
- 规则3：使用@JsonTest进行JSON序列化测试
- 规则4：使用@MockBean进行依赖模拟
- 规则5：适当配置测试配置文件
- 规则6：使用@TestConfiguration进行自定义测试设置

## 规则1：使用@WebMvcTest进行Web层测试

标题：使用@WebMvcTest隔离测试控制器
描述：使用@WebMvcTest仅测试Web层（控制器），而不加载完整的应用程序上下文。此注解配置Spring MVC基础设施并自动配置MockMvc以测试HTTP请求和响应。

**良好示例：**

```java
@WebMvcTest(UserController.class)
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void shouldReturnUserWhenValidId() throws Exception {
        // Given
        User user = new User(1L, "John Doe", "john@example.com");
        when(userService.findById(1L)).thenReturn(user);

        // When & Then
        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.name").value("John Doe"))
            .andExpect(jsonPath("$.email").value("john@example.com"));
    }
}
```

**不良示例：**

```java
@SpringBootTest
@AutoConfigureTestDatabase
class UserControllerTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void shouldReturnUser() {
        // 这不必要地加载了整个应用程序上下文
        // 并且需要为简单的控制器测试设置数据库
        ResponseEntity<User> response = restTemplate.getForEntity("/api/users/1", User.class);
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
    }
}
```

## 规则2：使用@JdbcTest进行Repository层测试

标题：使用@JdbcTest测试JDBC Repository
描述：使用@JdbcTest隔离测试Spring Data JDBC repository。此注解配置内存数据库，自动配置JdbcTemplate和NamedParameterJdbcTemplate，并加载Spring Data JDBC repository而不加载完整的应用程序上下文。

**良好示例：**

```java
@JdbcTest
class UserRepositoryTest {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private UserRepository userRepository;

    @Test
    void shouldFindUserByEmail() {
        // Given
        User user = new User(null, "John Doe", "john@example.com");
        User saved = userRepository.save(user);

        // When
        Optional<User> found = userRepository.findByEmail("john@example.com");

        // Then
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("John Doe");
        assertThat(found.get().getEmail()).isEqualTo("john@example.com");
    }

    @Test
    void shouldReturnEmptyWhenUserNotFound() {
        // When
        Optional<User> found = userRepository.findByEmail("nonexistent@example.com");

        // Then
        assertThat(found).isEmpty();
    }

    @Test
    void shouldUseJdbcTemplateForCustomQueries() {
        // Given
        jdbcTemplate.update(
            "INSERT INTO users (name, email) VALUES (?, ?)", 
            "Jane Smith", "jane@example.com"
        );

        // When
        Long count = jdbcTemplate.queryForObject(
            "SELECT COUNT(*) FROM users WHERE email LIKE '%@example.com'", 
            Long.class
        );

        // Then
        assertThat(count).isEqualTo(1L);
    }
}
```

**不良示例：**

```java
@SpringBootTest
class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;

    @Test
    void shouldFindUserByEmail() {
        // 这为简单的repository测试不必要地加载了
        // 整个应用程序上下文和所有bean
        User user = new User(null, "John Doe", "john@example.com");
        userRepository.save(user);

        Optional<User> found = userRepository.findByEmail("john@example.com");
        assertThat(found).isPresent();
    }
}
```

## 规则3：使用@JsonTest进行JSON序列化测试

标题：使用@JsonTest测试JSON序列化/反序列化
描述：使用@JsonTest隔离测试JSON序列化和反序列化逻辑。此注解自动配置Jackson ObjectMapper并提供JacksonTester助手以测试JSON操作。

**良好示例：**

```java
@JsonTest
class UserJsonTest {

    @Autowired
    private JacksonTester<User> json;

    @Test
    void shouldSerializeUser() throws Exception {
        // Given
        User user = new User(1L, "John Doe", "john@example.com");

        // When & Then
        assertThat(json.write(user))
            .hasJsonPathNumberValue("$.id", 1)
            .hasJsonPathStringValue("$.name", "John Doe")
            .hasJsonPathStringValue("$.email", "john@example.com");
    }

    @Test
    void shouldDeserializeUser() throws Exception {
        // Given
        String content = """
            {
                "id": 1,
                "name": "John Doe", 
                "email": "john@example.com"
            }
            """;

        // When & Then
        assertThat(json.parse(content))
            .usingRecursiveComparison()
            .isEqualTo(new User(1L, "John Doe", "john@example.com"));
    }
}
```

**不良示例：**

```java
@SpringBootTest
class UserJsonTest {

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void shouldSerializeUser() throws Exception {
        // 仅为JSON测试加载完整的应用程序上下文
        // 是过度的且缓慢的
        User user = new User(1L, "John Doe", "john@example.com");
        String json = objectMapper.writeValueAsString(user);

        assertThat(json).contains("John Doe");
    }
}
```

## 规则4：使用@MockBean进行依赖模拟

标题：使用@MockBean模拟外部依赖
描述：使用@MockBean模拟被测试组件依赖的Spring bean。这会在Spring上下文中用Mockito mock替换bean，允许您在测试期间控制其行为。

**良好示例：**

```java
@WebMvcTest(OrderController.class)
class OrderControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private OrderService orderService;

    @MockBean 
    private PaymentService paymentService;

    @Test
    void shouldCreateOrder() throws Exception {
        // Given
        CreateOrderRequest request = new CreateOrderRequest("Product A", 2);
        Order order = new Order(1L, "Product A", 2, BigDecimal.valueOf(100.00));

        when(orderService.createOrder(any(CreateOrderRequest.class))).thenReturn(order);

        // When & Then
        mockMvc.perform(post("/api/orders")
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                        "productName": "Product A",
                        "quantity": 2
                    }
                    """))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.productName").value("Product A"));
    }
}
```

**不良示例：**

```java
@WebMvcTest(OrderController.class)
class OrderControllerTest {

    @Autowired
    private MockMvc mockMvc;

    // 缺少@MockBean - 这会导致测试失败
    // 因为OrderService在上下文中不可用

    @Test
    void shouldCreateOrder() throws Exception {
        mockMvc.perform(post("/api/orders")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{}"))
            .andExpect(status().isCreated());
        // 由于缺少依赖，此测试会失败
    }
}
```

## 规则5：适当配置测试配置文件

标题：使用测试配置文件进行环境特定配置
描述：配置特定的测试配置文件以覆盖测试场景的应用程序属性。使用@ActiveProfiles激活与生产设置不同的测试特定配置。

**良好示例：**

```java
@JdbcTest
@ActiveProfiles("test")
class UserRepositoryIntegrationTest {

    @Autowired
    private UserRepository userRepository;

    @Test
    void shouldUseTestDatabaseConfiguration() {
        // 测试将使用application-test.yml配置
        // 其中可能指定H2内存数据库
        User user = new User(null, "Test User", "test@example.com");
        User saved = userRepository.save(user);

        assertThat(saved.getId()).isNotNull();
    }
}
```

**不良示例：**

```java
@JdbcTest
class UserRepositoryIntegrationTest {

    // 没有@ActiveProfiles注解
    // 这可能使用生产数据库配置
    // 导致不可靠或缓慢的测试

    @Autowired
    private UserRepository userRepository;

    @Test
    void shouldSaveUser() {
        User user = new User(null, "Test User", "test@example.com");
        userRepository.save(user);
    }
}
```

## 规则6：使用@TestConfiguration进行自定义测试设置

标题：使用@TestConfiguration创建自定义测试配置
描述：使用@TestConfiguration定义测试特定的bean配置，在测试期间覆盖或补充主应用程序配置。

**良好示例：**

```java
@WebMvcTest(UserController.class)
class UserControllerTest {

    @TestConfiguration
    static class TestConfig {

        @Bean
        @Primary
        public Clock testClock() {
            return Clock.fixed(
                Instant.parse("2023-12-01T10:00:00Z"), 
                ZoneOffset.UTC
            );
        }
    }

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void shouldUseFixedTimeForTesting() throws Exception {
        // 使用可预测的时间进行测试以获得一致的结果
        mockMvc.perform(get("/api/users/current-time"))
            .andExpect(status().isOk())
            .andExpect(content().string("2023-12-01T10:00:00Z"));
    }
}
```

**不良示例：**

```java
@WebMvcTest(UserController.class)
class UserControllerTest {

    // 对于时间依赖测试没有测试配置
    // 这使得测试不可靠且难以重现

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void shouldReturnCurrentTime() throws Exception {
        mockMvc.perform(get("/api/users/current-time"))
            .andExpected(status().isOk());
        // 由于系统时钟依赖，无法断言确切的时间值
    }
}
```

### 其他切片测试注解

**@WebFluxTest**：用于测试Spring WebFlux响应式Web应用程序
**@RestClientTest**：用于测试REST客户端和@RestTemplate配置  
**@AutoConfigureTestDatabase**：用于在切片测试中配置测试数据库
**@TestPropertySource**：用于在测试场景中覆盖特定属性
**@DataJdbcTest**：@JdbcTest的替代方案，专门专注于Spring Data JDBC repository
**@Sql**：用于在JDBC测试中测试执行前执行SQL脚本